<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Austin Elixir - Routing Securely with Phoenix Framework</title>

		<meta name="description" content="How to start a new Phoenix Framework project, setup users and authentication that works for both HTML and JSON API before enabling XSS-proof chat using channels.  The different requirements for HTML, JSON, and channel authentication with XSS and CSRF protection will be emphasized.">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Austin Elixir</h1>
					<h2>Routing Securely with Phoenix Framework</h2>
					<p>2015-09-02</p>
					<p>Luke Imhoff</p>
					<table>
                        <tbody>
                        <tr>
                            <th>
                                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                                     version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px"
                                     viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                     <g>
                                        <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                        <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                        <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                        <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                     </g>
                                </svg>
                            </th>
                            <td>luke_imhoff@rapid7.com</td>
                            <td>Kronic.Deth@gmail.com</td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg"
                                     xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16"
                                     enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                               </svg>
                            </th>
                            <td>
                                <a href="https://github.com/limhoff-r7" target="_blank">@limhoff-r7</a>
                            </td>
                            <td>
                                <a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        <tr>
                            <th>
                                <svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
                            </th>
                            <td></td>
                            <td>
                                <a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        <p>
                            I am a Senior Software Engineer at Rapid7 in Austin.  I works on Metasploit, a computer
                            security project that provides information about security vulnerabilities and aids in
                            penetration testing, written in Ruby, but I'm leading an effort to transition some of the
                            project to Elixir.
                        </p>
                        <p>
                            In my free time I am the maintainer of IntelliJ Elixir, an Elixir plugin for JetBrains IDEs,
                            like IntellIJ IDEA and Rubymine.
                        </p>
                    </aside>
				</section>
                <section>
                    <h1>Outline</h1>
                    <ol>
                        <li>
                            <a href="#/installation">Installation</a>
                        </li>
                        <li>
                            <a href="#/new">New Project</a>
                        </li>
                        <li>
                            <a href="#/configuration">Configuration</a>
                        </li>
                        <li>
                            <a href="#/tls">TLS</a>
                        </li>
                        <li>
                            <a href="#/authentication">Authentication</a>
                        </li>
                        <li>
                            <a href="#/csrf">CSRF</a>
                        </li>
                        <li>
                            <a href="#/channels">Channels</a>
                        </li>
                    </ol>
                </section>
                <section class="stack">
                    <section id="installation">
                        <h1>Installation</h1>
                        <ul>
                            <li>
                                <a href="#/installation-node">Node</a>
                            </li>
                            <li>
                                <a href="#/installation-mix"><code>mix</code> archives</a>
                            </li>
                        </ul>
                    </section>
                    <section id="installation-node">
                        <h1>Node</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Source</th>
                                <th>Linux</th>
                                <th>Mac</th>
                                <th>Windows</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <a href="https://nodejs.org/download/">nodejs.org</a>
                                </td>
                                <td>
                                    <a href="https://nodejs.org/dist/v0.12.7/node-v0.12.7-linux-x64.tar.gz">
                                        <code>tar.gz</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://nodejs.org/dist/v0.12.7/node-v0.12.7.pkg">
                                        <code>pkg</code>
                                    </a>
                                <td>
                                    <a href="https://nodejs.org/dist/v0.12.7/node-v0.12.7-x86.msi">
                                        <code>msi</code>
                                    </a>
                                </td>
                            </tr>
                            <tr>
                                <td>homebrew</td>
                                <td></td>
                                <td><code>brew install node</code></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>apt-get</td>
                                <td>
                                    <code>sudo apt-get install nodejs-legacy</code>
                                </td>
                                <td></td>
                                <td></td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Node is required for brunch.io, which is used for asset compilation.  It is optional,
                                but I'll be using it as it's easiest to setup when starting a new phoenix project.
                            </p>
                            <p>
                                I'm going to assume you already have Erlang and Elixir installed.
                            </p>
                        </aside>
                    </section>
                    <section id="installation-mix">
                        <h1>Installing Mix Archives</h1>
                        <pre><code class="bash" data-trim>
mix local.hex
mix archive.install https://github.com/phoenixframework/phoenix/releases/download/v0.17.0/phoenix_new-0.17.0.ez
                        </code></pre>
                        <aside class="notes">
                            <p>
                                <code>mix local.hex</code> ensures your version of the hex package manager is up-to-date.
                            </p>
                            <p>
                                The archive DOT install (<code>archive.install</code>) pulls down the
                                phoenix DOT new (<code>phoenix.new</code>) task from github.
                            </p>
                            <p>
                                As you can see by the URL, this talk is based on Phoenix zero dot seventeen (0.17),
                                which was the latest version as of 2015-08-20.  zero DOT seventeen is the last release
                                before one dot zero (1.0).
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="new">
                        <h1>New Project</h1>
                        <ol>
                            <li>
                                <a href="#/new-mix-phoenix-options">
                                    <code>mix phoenix.new</code> Options
                                </a>
                            </li>
                            <li>
                                <a href="#/new-mix-phoenix">
                                    <code>mix phoenix.new</code>
                                </a>
                            </li>
                            <li>
                                <p>Fetch and Install Dependencies</p>
                                <ul>
                                    <li>
                                        <a href="#/new-fetch-and-install-dependencies">
                                            New
                                        </a>
                                    </li>
                                    <li>
                                        <a href="#/new-clone-fetch-and-install-dependencies">
                                            Clone
                                        </a>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <a href="#/new-run">
                                    Run
                                </a>
                            </li>
                        </ol>
                    </section>
                    <section id="new-mix-phoenix-options">
                        <h1>
                            <code>mix phoenix.new</code> Options
                        </h1>
                        <table>
                            <thead>
                            <tr>
                                <th>
                                    Option
                                </th>
                                <th>
                                    Description
                                </th>
                                <th>
                                    Format
                                </th>
                                <th>
                                    Example
                                </th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>--app APP</code>
                                </td>
                                <td>The name of the OTP application</td>
                                <td>Atom</td>
                                <td>
                                    <code>routing_securely_with_phoenix_framework</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>--database DATABASE</code>
                                </td>
                                <td>Specify the database adapter for ecto</td>
                                <td>
                                    <ul>
                                        <li>
                                            <code>mssql</code>
                                        </li>
                                        <li>
                                            <code>mysql</code>
                                        </li>
                                        <li>
                                            <code>postgres</code> (default)
                                        </li>
                                        <li>
                                            <code>sqlite</code>
                                        </li>
                                    </ul>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <code>--module MODULE</code>
                                </td>
                                <td>The name of the base module in the generated skeleton</td>
                                <td>Alias</td>
                                <td>
                                    <code>RoutingSecurelyWithPhoenixFramework</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>--no-ecto</code>
                                </td>
                                <td>Do not generate Ecto files for the model layer</td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <code>--no-brunch</code>
                                </td>
                                <td>Do not generate brunch files for static asset building</td>
                                <td></td>
                                <td></td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Normally, you don't need to specify any of these options and they are just derived
                                from the directory name, but if you want to use a different naming scheme or
                                nested namespaces, you'll need to manually override APP and MODULE.
                            </p>
                            <p>
                                By default, phoenix dot new (<code>phoenix.new</code>) will use Ecto with Postgres,
                                but if you prefer a different database you can override that with dash dash database
                                (<code>--database</code>).  If you don't need a database at all, you can disable Ecto
                                with dash dash no dash ecto (<code>--no-ecto</code>).
                            </p>
                            <p>
                                Even if you need a database, you could still create the project without ecto if you
                                want to use a built-in Erlang database like Mnesia or DETS.  Or a NOSQL alternative like
                                Riak that Ecto doesn't support.
                            </p>
                            <p>
                                You could dash dash no dash brunch (<code>--no-brunch</code>) if you want to use
                                something other than brunch, such as webpack, to compile your assets, or if you
                                don't have HTML or assets because you're just building a JSON API or channel server.
                            </p>
                        </aside>
                    </section>
                    <section id="new-mix-phoenix">
                        <h1>
                            <code>mix phoenix.new</code>
                        </h1>
                        <img alt="mix phoenix.new routing_securely_with_phoenix_framework"
                             class="stretch"
                             src="images/mix%20phoenix.new.png"/>
                        <aside class="notes">
                            <p>
                                mix phoenix dot new (<code>mix phoenix.new</code>) with only a path will create config
                                files for dev, prod, and test environments; a single endpoint for this project; views
                                for errors and layout; ExUnit-based tests; a user socket for handling client connections
                                for channels; a default page controller; templates for the layout and page views;
                                the routes; the Ecto repo; and the default assets.
                            </p>
                        </aside>
                    </section>
                    <section id="new-fetch-and-install-dependencies">
                        <h1>Fetch and Install Dependencies</h1>
                        <img alt="Fetch and install dependencies to install javascript libraries with npm install and install elixir dependencies with mix deps.get"
                             class="stretch"
                             src="images/fetch-and-install-dependencies.png">
                        <aside class="notes">
                            <p>
                                mix phoenix dot new (<code>mix phoenix.new</code>) is interactive and after creating the
                                files we saw on the last slide, the mix task will ask if you want to install
                                dependencies.
                            </p>
                            <p>
                                Saying 'yes', will install the javascript dependencies with N-P-M install
                                (<code>npm install</code>) and the Elixir dependencies with mix deps dot get
                                (<code>mix deps.get</code>)
                            </p>
                            <p>
                                Please take note that the prompt only happens when creating a new project.  If you clone
                                a pre-existing project...
                            </p>
                        </aside>
                    </section>
                    <section id="new-clone-fetch-and-install-dependencies">
                        <h1>Fetching and Install Dependencies for Clone</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Error</th>
                                <th>Solution</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <img alt="Error telling user to run mix deps.get when running mix phoenix.server"
                                         src="images/unchecked-dependency-error.png"
                                         style="height: 40; width: auto"/>
                                </td>
                                <td>
                                    <code>mix deps.get</code>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <img alt="Error telling user to run npm install for brunch when running mix phoenix.server"
                                         src="images/node-watcher-error.png"
                                         style="height: 40vh; width: auto"/>
                                </td>
                                <td>
                                    <code>npm install</code>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                ...you need to run mix deps dot get (<code>mix deps.get</code>) and
                                N-P-M install (<code>npm install</code>) manually.
                            </p>
                            <p>
                                If you forget to run either of these steps and start mix phoenix dot server
                                (<code>mix phoenix.server</code>), the log will helpfully contain errors telling you
                                the command to run.
                            </p>
                            <p>
                                In Phoenix, and Elixir in general, if an error message isn't helpful it is considered a
                                bug and you should open an issue with the project on Github.
                            </p>
                        </aside>
                    </section>
                    <section>
                        <h1>Run your application</h1>
                        <img alt="cd routing_securely_with_phoenix; mix ecto.create; mix phoenix.server"
                             class="stretch"
                             src="images/run.png"/>
                        <aside class="notes">
                            <p>
                                The output from mix phoenix dot new (<code>mix phoenix.new</code>) will now tell you
                                to C-D (<code>cd</code>) to project directory; create the database; and run the server,
                                but before you do that you should secure your database.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="configuration">
                        <h1>Configuration</h1>
                        <ul>
                            <li>
                                <a href="#/configuration-default">
                                    Default Configuration
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-remove-shared-secret-key-base">
                                    Remove Shared <code>secret_key_base</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-secret-configuration-for-each-environment">
                                    Secret configuration for each environment
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-secret-key-base">
                                    Generating new <code>secret_key_base</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-password">
                                    Generating database passwords
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-dev-secret">
                                    <code>config/dev.secret.exs</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-test-secret">
                                    <code>config/test.secret.exs</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-create-user">
                                    Create PostgreSQL users
                                </a>
                            </li>
                            <li>
                                <a href="#/configuration-create-database">
                                    Create Database
                                </a>
                            </li>
                        </ul>
                    </section>
                    <section id="#/configuration">
                        <h1>Default Configuration</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Environment</th>
                                <th>Module</th>
                                <th>key</th>
                                <th>File</th>
                                <th>Source Controlled?</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>All</td>
                                <td>
                                    <code>Endpoint</code>
                                </td>
                                <td>
                                    <code>secret_key_base</code>
                                </td>
                                <td>
                                    <code>config/config.exs</code>
                                </td>
                                <td>Yes</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>dev</code>
                                </td>
                                <td>
                                    <code>Repo</code>
                                </td>
                                <td>
                                    <code>password</code>
                                </td>
                                <td>
                                    <code>config/dev.exs</code>
                                </td>
                                <td>Yes</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>prod</code>
                                </td>
                                <td>
                                    <code>Endpoint</code>
                                </td>
                                <td>
                                    <code>secret_key_base</code>
                                </td>
                                <td>
                                    <code>config/prod.secret.exs</code>
                                </td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>prod</code>
                                </td>
                                <td>
                                    <code>Repo</code>
                                </td>
                                <td>
                                    <code>password</code>
                                </td>
                                <td>
                                    <code>config/prod.secret.exs</code>
                                </td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>test</code>
                                </td>
                                <td>
                                    <code>Repo</code>
                                </td>
                                <td>
                                    <code>password</code>
                                </td>
                                <td>
                                    <code>config/test.exs</code>
                                </td>
                                <td>Yes</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Phoenix projects have two secrets: the secret key base and the database password.
                            </p>
                            <p>
                                The secret key base is used by Plug for the session encryption and signing and by
                                Phoenix for channel tokens.  If the secret key base is disclosed, it's possible to
                                either read session cookies or fake cookies by signing session cookies containing your
                                own data.
                            </p>
                            <p>
                                The database password is of course used to log into database.  If the database password
                                is disclosed all your data is accessible.
                            </p>
                            <p>
                                By default, the <code>prod</code> secrets are kept is a separate prod dot secret dot
                                E-X-S (<code>prod.secret.exs</code>) that is git ignored.  Not keeping production
                                secrets in source control is a best practice.
                            </p>
                            <p>
                                But, by default, Phoenix does keep your development and test secrets in source control.
                                I see two problems with this: first, it means that your entire team uses the same
                                secrets and second, if your repository is public I can see your secrets on github.
                            </p>
                            <p>
                                You may think these aren't issues because they're not meant for production, but
                                if you end up replicating part of your production data to development to fix a bug
                                and some one gets access to your network, you can end up divulging production data to
                                the attacker.
                            </p>
                            <p>
                                Additionally, if you have reused and/or weak password, an attacker can use your
                                <code>dev</code> or <code>test</code> passwords to more easily guess your production
                                passwords.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-remove-shared-secret-key-base">
                        <h1>Remove shared <code>secret_key_base</code></h1>
                        <img alt="Remove secret_key_base from config/config.exs"
                             class="stretch"
                             src="images/remove-secret-key-base-from-config-config-exs.png"/>
                        <aside class="notes">
                            <p>
                                The first step to securing the configuration is to remove the shared
                                <code>secret_key_base</code> from <code>config/config.exs</code>, which will force
                                each environment to supply their own <code>secret_key_base</code>.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-secret-configuration-for-each-environment">
                        <h1>Secret configuration for each environment</h1>
                        <figure>
                            <figcaption>
                                Remove secret configuration import from <code>config/prod.exs</code>
                            </figcaption>
                            <img alt="Remove improt_config &quot;prod.secret.exs&quot; in config/prod.exs"
                                 src="images/remove-secret-configuration-import-from-prod.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <figure>
                            <figcaption>
                                Import secret configuration for each environment in <code>config/config.exs</code>
                            </figcaption>
                            <img alt="import_config &quot;#{Mix.env}.secret.exs&quot; in config/config.exs"
                                 src="images/import-config-mix-env-secret-exs.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <figure>
                            <figcaption>
                                Ignore all secret configurations in git
                            </figcaption>
                            <img alt="git ignore config/*.secret.exs instead of config/prod.secret.exs"
                                 src="images/git-ignore-all-secret-configurations.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <aside class="notes">
                            <p>
                                The secrets for all configurations should be kept out of source control, so we'll remove
                                the import config prod dot secret dot E-X-S
                                (<code>import_config "prod.secret.exs"</code>) from config slash prod dot E-X-S
                                (<code>config/prod.exs</code>) and add an import that uses mix dot env
                                (<code>Mix.env</code>) to import an environment-specific secret configuration in
                                config slash config dot E-X-S (<code>config/config.exs</code>).
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-secret-key-base">
                        <h1>Generating new <code>secret_key_base</code></h1>
                        <pre><code class="elixir" data-trim>
iex(1)> length = 64
64
iex(2)> :crypto.strong_rand_bytes(length) |> Base.encode64 |> binary_part(0, length)
                        </code></pre>
                        <aside class="notes">
                            <p>
                                crypto strong rand bytes (<code>:crypto.strong_random_bytes</code>) is the equivalent of
                                using secure random (<code>SecureRandom</code>) in Ruby or reading from slash dev slash
                                random (<code>/dev/random</code>) in Linux.
                            </p>
                            <p>
                                This is the same code as mix phoenix dot new (<code>mix phoenix.new</code>) uses.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-password">
                        <h1>Generating database password</h1>
                        <ul>
                            <li>
                                Use a password manager
                            </li>
                            <li>
                                Make the password long (> 16 characters)
                            </li>
                            <li>
                                Replace password every 90 days
                            </li>
                        </ul>
                        <br/>
                        <img alt="Using KeePass to generate a 64 character password with lowe letter, upper letters, numbers, and special characters that expires in 3 months"
                             class="scretch"
                             src="images/keepassx.png"/>
                        <aside class="notes">
                            <p>
                                The advice for a strong password applies even more so for <code>prod</code> than it does
                                for <code>dev</code> or <code>test</code>.
                            </p>
                            <p>
                                In addition to replacing your passwords every 90 days you should do the same for your
                                secret key bases.  This will invalidate any active sessions that the user has, but this
                                is a good thing because your users should also be replacing their passwords every 90
                                days.
                            </p>
                            <p>
                                Here, I'm using KeePassX to generate a strong password and store it, so I have it on
                                file if I accidentally delete my secret configuration files.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-dev-secret">
                        <h1>Dev Secrets</h1>
                        <figure>
                            <figcaption>
                                Remove <code>Repo</code> configuration from <code>config/dev.exs</code>
                            </figcaption>
                            <img alt="Remove config APP_NAME, MODULE_NAME.Repo from config/dev.exs"
                                 src="images/remove-repo-from-config-dev-exs.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <figure>
                            <figcaption>
                                Create <code>config/dev.secret.exs</code>
                            </figcaption>
                            <pre><code class="elixir" data-trim>
use Mix.Config

# In this file, we keep development configuration that
# you likely want to automate and keep it away from
# your version control system.
config :routing_securely_with_phoenix_framework, RoutingSecurelyWithPhoenixFramework.Endpoint,
  secret_key_base: "SECRET_KEY_BASE"

# Configure your database
config :routing_securely_with_phoenix_framework, RoutingSecurelyWithPhoenixFramework.Repo,
  adapter: Ecto.Adapters.Postgres,
  database: "routing_securely_with_phoenix_framework_dev",
  host: "127.0.0.1",
  password: "PASSWORD",
  size: 20, # The amount of database connections in the pool
  username: "routing_securely_with_phoenix_framework_dev"
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The config slash dev dot secret dot exs (<code>config/dev.secret.exs</code>) will have
                                the secret key base for the endpoint and the entire repo configuration.
                            </p>
                            <p>
                                You could put the common keys for the repo configuration in config slash config dot
                                E-X-S (<code>config/config/exs</code>), but this way the reader doesn't need to know
                                which keys are defaults.
                            </p>
                            <p>
                                Notice that I'm using a separate username, that matches the database name.  This way the
                                user can have the minimum permissions to only interact with its own database.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-test-secret">
                        <h1>Test Secrets</h1>
                        <figure>
                            <figcaption>
                                Remove <code>Repo</code> configuration from <code>config/test.exs</code>
                            </figcaption>
                            <img alt="Remove config APP_NAME, MODULE_NAME.Repo from config/test.exs"
                                 src="images/remove-repo-from-config-test-exs.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <figure>
                            <figcaption>
                                Create <code>config/test.secret.exs</code>
                            </figcaption>
                            <pre><code class="elixir" data-trim>
use Mix.Config

# In this file, we keep development configuration that
# you likely want to automate and keep it away from
# your version control system.
config :routing_securely_with_phoenix_framework, RoutingSecurelyWithPhoenixFramework.Endpoint,
  secret_key_base: "SECRET_KEY_BASE"

# Configure your database
config :routing_securely_with_phoenix_framework, RoutingSecurelyWithPhoenixFramework.Repo,
  adapter: Ecto.Adapters.Postgres,
  database: "routing_securely_with_phoenix_framework_test",
  password: "PASSWORD",
  pool: Ecto.Adapters.SQL.Sandbox,
  username: "routing_securely_with_phoenix_framework_test"
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The secrets for <code>test</code> look the same as those for <code>dev</code>, except
                                for the removal of the <code>size</code> option and addition of the <code>pool</code>in
                                <code>Repo</code>.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-create-user">
                        <h1>Create PostgreSQL Users</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Termianl</th>
                                <th>pgAdmin</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>1</th>
                                <td>
                                    <code>createuser --createdb --encrypted --no-createrole --no-superuser --pwprompt USERNAME</code>
                                </td>
                                <td>Start pgAdmin3</td>
                            </tr>
                            <tr>
                                <th>2</th>
                                <td>Enter password</td>
                                <td>Connect to server</td>
                            </tr>
                            <tr>
                                <th>3</th>
                                <td>Enter password (again)</td>
                                <td>Right-click Login Roles</td>
                            </tr>
                            <tr>
                                <th>4</th>
                                <td></td>
                                <td>Click New Login Role</td>
                            </tr>
                            <tr>
                                <th>5</th>
                                <td></td>
                                <td>Enter <code>username<code> as Role Name</td>
                            </tr>
                            <tr>
                                <th>6</th>
                                <td></td>
                                <td>Change to Definition Tab</td>
                            </tr>
                            <tr>
                                <th>7</th>
                                <td></td>
                                <td>Enter password</td>
                            </tr>
                            <tr>
                                <th>8</th>
                                <td></td>
                                <td>Enter password (again)</td>
                            </tr>
                            <tr>
                                <th>9</th>
                                <td></td>
                                <td>Change to Role Privileges Tab</td>
                            </tr>
                            <tr>
                                <th>10</th>
                                <td></td>
                                <td>Click "Can create database"</td>
                            </tr>
                            <tr>
                                <th>11</th>
                                <td></td>
                                <td>Click OK</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                I normally use pgAdmin3 to create users and database as it's easier to check my work,
                                but if you're following along and prefer something you can copy and paste into the
                                terminal, I've included that.
                            </p>
                        </aside>
                    </section>
                    <section id="configuration-create-database">
                        <h1>Create the database</h1>
                        <figure>
                            <figcaption><code>mix ecto.create</code> for new project</figcaption>
                            <img alt="Top lines of mix ecto.create in new project compile fs application"
                                 src="images/mix-ecto-create-uncompiled-top.png"
                                 style="height: auto; width: 100%"/>
                            <br/>
                            <img alt="Bottom lines of mix.ecto.create in new project generate app and finally create the database"
                                 src="images/mix-ecto-create-uncompiled-bottom.png.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <figure>
                            <figcaption><code>mix ecto.create</code> in built project</figcaption>
                            <img alt="mix ecto.create in a pre-built project does not compile and only creates the database"
                                 src="images/mix-ecto-create-compiled.png"
                                 style="height: auto; width: 100%"/>
                        </figure>
                        <aside class="notes">
                            <p>
                                Now with the secrets outside of source control, we can create the database using the
                                command that mix phoenix dot new (<code>mix phoenix.new</code>) gave us.
                            </p>
                            <p>
                                You may wonder what's going on when you run the command: you'll see all this output
                                about files being compiled and wonder why you're compiling to create a database.  Mix
                                compiles the dependencies before creating the database because Ecto is a dependency
                                of your project and so needs to be built for it to connect to PostgreSQL and create the
                                database.
                            </p>
                            <p>
                                If you run mix ecto dot create (<code>mix ecto.create</code>) in a project where the
                                dependencies are already compiled, then you'll just get the bottom message.  Seeing
                                the compilation message for ecto dot create (<code>ecto.create</code>) is a side-effect
                                of it being the first mix command you ran.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="tls">
                        <h1>TLS</h1>
                        <ul>
                            <li>
                                <a href="#/tls-overview">Overview</a>
                            </li>
                            <li>
                                <a href="#/tls-certificate-authority-key">Certificate Authority Key</a>
                            </li>
                            <li>
                                <a href="#/tls-self-signing-certificate-authority">
                                    Self-Signing Certificate Authority
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-self-signing-certificate-authority-distinguished-name">
                                    Self-Signing Certificate Authority Distinguished Name
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-self-signed-certificate-authority-view">
                                    Viewing your self-signed certificate
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-server-key">Server Key</a>
                            </li>
                            <li>
                                <a href="#/tls-server-certificate-signing-request">
                                    Server Certificate Signing Request
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-server-certificate-signing-request-distinguished-name">
                                    Server Certificate Signing Request Distinguished Name
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-signed-server-certificate">
                                    Signed Server Certificate
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-server-certificate-signing">
                                    Signing Server Certificate Request
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-trust-self-signed-certificate-authority">
                                    Trust Self-Signed Certificate Authority
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-fully-qualified-domain-setup">
                                    Fully-qualified Domain Setup
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-testing">
                                    Testing TLS Connection
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-configuration">
                                    TLS Configuration
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-configuration-dev">
                                    TLS <code>dev</code> Configuration
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-configuration-prod">
                                    TLS <code>prod</code> Configuration
                                </a>
                            </li>
                            <li>
                                <a href="#/tls-configuration-test">
                                    TLS <code>test</code> Configuration
                                </a>
                            </li>
                        </ul>
                    </section>
                    <section id="tls-overview">
                        <h1>Overview</h1>
                        <ul>
                            <li>Transport Layer Security</li>
                            <li>Successor to SSL (Secure Socket Layer) 3.0</li>
                            <li>TLS 1.0 was defined in 1999</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                H-T-T-P-S should no longer use S-S-L.  When speaking about the encryption for H-T-T-P-S,
                                you should say T-L-S now.
                            </p>
                            <p>
                                Phoenix, through Plug has built-in support for T-L-S without the need for a reverse
                                proxy like engine-X (<code>nginx</code>).
                            </p>
                        </aside>
                    </section>
                    <section id="tls-certificate-authority-key">
                        <h1>Certificate Authority Key</h1>
                        <table>
                            <caption><code>openssl genrsa -des3 -out certificate-authority.key 4096</code></caption>
                            <thead>
                            <tr>
                                <th>Option</th>
                                <th>Argument</th>
                                <th>Description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td></td>
                                <td>
                                    <code>genrsa</code>
                                </td>
                                <td>Generate RSA key</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-des3</code>
                                </td>
                                <td></td>
                                <td>Password protect the private key</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-out</code>
                                </td>
                                <td>
                                    <code>certificate-authority.key</code>
                                </td>
                                <td>
                                    Private Key file
                                </td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>4096</td>
                                <td>Number of bits in RSA key</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                To start making our own certificate authority, we need to generate a private key for
                                the certificate authority.
                            </p>
                            <p>
                                Use your password manager to generate a long password for this private key.
                            </p>
                            <p>
                                We'll choose 4096 bits to be extra careful.  The current recommendation is only 2048
                                bits.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-self-signing-certificate-authority">
                        <h1>Self-Signing Certificate Authority</h1>
                        <table>
                            <caption>
                                <code>openssl req -new -x509 -days 365 -key certificate-authority.key -out certificate-authority.crt -sha256</code>
                            </caption>
                            <thead>
                            <tr>
                                <th>Option</th>
                                <th>Argument</th>
                                <th>Description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td></td>
                                <td>
                                    <code>req</code>
                                </td>
                                <td>X.509 Certificate Signing Request (CSR) Management</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-new</code>
                                </td>
                                <td></td>
                                <td>New Certificate Request</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-x509</code>
                                </td>
                                <td></td>
                                <td>Self-signed certificate</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-days</code>
                                </td>
                                <td>
                                    <code>365</code>
                                </td>
                                <td>Number of days certificate is valid</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-key</code>
                                </td>
                                <td>
                                    <code>certificate-authority.key</code>
                                </td>
                                <td>Input file name for private key used for signing</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-out</code>
                                </td>
                                <td>
                                    <code>certificate-authority.crt</code>
                                </td>
                                <td>
                                    Output file for self-signed certificate
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-sha256</code>
                                </td>
                                <td></td>
                                <td>Sign using SHA256 instead of SHA1</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Non-self-signed certificates usually last from 1 to 3 years.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-self-signing-certificate-authority-distinguished-name">
                        <h1>Self-Signing Certificate Authorithy Distinguished Name</h1>
                        <img alt="Entering C,ST,L,O,CN, and emailAddress for distinguished name"
                             class="stretch"
                             src="images/self-signing-certificate-authorithy-distinguished-name.png">
                    </section>
                    <section id="tls-self-signed-certificate-authority-view">
                        <h1>Viewing your self-signed certificate</h1>
                        <h2><code>openssl x509 -in certificate-authority.crt -noout -text</code></h2>
                        <img alt="Data stored in certificate-authority.pem"
                             class="stretch"
                             src="images/viewing-your-self-signed-certificate-authority.png">
                        <aside class="notes">
                            <p>
                                It's a good idea to check your work, which you can do with the X-509 subcommand
                                for <code>openssl</code>.
                            </p>
                            <p>
                                You can see that the Issuer and the Subject have the same distinguished name, which
                                is the hallmark of a self-signed certificate.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-server-key">
                        <h1>Server Key</h1>
                        <code>openssl genrsa -out server-${MIX_ENV}.key 4096</code>
                        <aside class="notes">
                            <p>
                                We'll generate a separate server key for each mix environment so that the server
                                certificate only works for the domain for each mix environemnt and we'll be alerted
                                if we start using the development or test URL with the wrong server.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-server-certificate-signing-request">
                        <h1>Server Certificate Signing Request</h1>
                        <code>openssl req -new -key server-${MIX_ENV}.key -out server-${MIX_ENV}.csr</code>
                        <aside class="notes">
                            <p>
                                Since the serer certificate is not self-signed, signing it is broken into two parts:
                                (1) the request for the server's key to be signed and (2) the certificate authority
                                actually doing the signing.
                            </p>
                            <p>
                                This two-part process makes sense when you think of how real Certificate Authorities
                                like Verisign have to sign your private key, but you don't want to send it to them to
                                do that.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-server-certificate-signing-request-distinguished-name">
                        <h1>Server Certificate Signing Request Distinguished Name</h1>
                        <img alt="Entering C,ST,L,O,CN, and emailAddress for distinguished name.  CN must match DNS name (dev.phoenix.localhost) of MIX_ENV server"
                             class="stretch"
                             src="images/server-certificate-signing-request-distinguished-name.png">
                        <aside class="notes">
                            <p>
                                I'll use the same country, state, locality, organization and email address as with the
                                self-signed certificate authority, but the Common Name for the server must match the
                                address I'll use to connect to the server, so in this case I'm using dev dot
                                phoenix dot localhost under the assumption that this is for <code>MIX_ENV=dev</code> and
                                I'll setup an etc host entry for dev dot phoenix dot locahost.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-server-certificate-signing">
                        <h1>Signing Server Certificate Request</h1>
                        <table>
                            <caption>
                                <code>openssl x509 -CA certificate-authority.crt  -CAcreateserial -CAkey certificate-authority.key -days 90 -in server-${MIX_ENV}.csr -out server-${MIX_ENV}.crt -req -sha256</code>
                            </caption>
                            <thead>
                            <tr>
                                <th>Option</th>
                                <th>Argument</th>
                                <th>Description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td></td>
                                <td>
                                    <code>x509</code>
                                </td>
                                <td>Certificate display and signing utility</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-CA</code>
                                </td>
                                <td>
                                    The Certificate Authority certificate
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-CAcreateserial</code>
                                </td>
                                <td></td>
                                <td>
                                    Create file for keeping track of CA issued certificate serial numbers if it does not
                                    exist and assign this certificate the next serial number.
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-CAkey</code>
                                </td>
                                <td>
                                    <code>certificate-authority.key</code>
                                </td>
                                <td>Certificate Authority private Key for signing request</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-days</code>
                                </td>
                                <td>
                                    <code>90</code>
                                </td>
                                <td>Days the server certificate is valid</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-in</code>
                                </td>
                                <td>
                                    <code>server-${MIX_ENV}.csr</code>
                                </td>
                                <td>
                                    Request to be signed
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-out</code>
                                </td>
                                <td>
                                    <code>server-${MIX_ENV}.crt</code>
                                </td>
                                <td>
                                    Signed certificate output file
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-req</code>
                                </td>
                                <td></td>
                                <td>Sign a certificate request</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>-sha256</code>
                                </td>
                                <td></td>
                                <td>Sign with SHA256 instead of SHA1</td>
                            </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="tls-trust-self-signed-certificate-authority">
                        <h1>Trust Self-Signed Certificate Authority</h1>
                        <h2>OSX</h2>
                        <ol>
                            <li>Open Keychain Access</li>
                            <li>Click Plus</li>
                            <li>Select <code>certificate-authority.crt</code></li>
                            <li>Highlight the certificate</li>
                            <li>Click i</li>
                            <li>Expand Trust</li>
                            <li>Change "When using this certificate" to Always Trust</li>
                            <li>Close i Dialog</li>
                            <li>Enter password to save changes</li>
                        </ol>
                        <aside class="notes">
                            <p>
                                The whole purpose of creating a self-signed certificate authority instead of
                                a single self-signed server certificate, was so that only one certificate needed to be
                                trusted for all environments.
                            </p>
                            <p>
                                Trusting the certificate authority will turn the padlock from red to green and stop
                                certificate warnings from your browser.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-fully-qualified-domain-setup">
                        <h1>Fully Qualified Domain Setup</h1>
                        <ol>
                            <li><code><pre>sudo vim /etc/hosts</pre></code></li>
                            <li>Add <code><pre>127.0.0.1 dev.routing-securely-with-phoenix-framework.localhost</pre></code></li>
                            <li>Add <code><pre>127.0.0.1 prod.routing-securely-with-phoenix-framework.localhost</pre></code></li>
                            <li>Add <code><pre>127.0.0.1 test.routing-securely-with-phoenix-framework.localhost</pre></code></li>
                            <li>Restart Browsers</li>
                        </ol>
                        <aside class="notes">
                            <p>
                                In order to use your server certificates, you'll need a way for their common names to
                                point at your local server.
                            </p>
                            <p>
                                To keep it simple, I'm just adding entries to slash etc slash hosts
                                (<code>/etc/hosts</code>) instead of setting up local DNS.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-configuration">
                        <h1>TLS Configuration</h1>
                        <img alt="config/config.exs TLS changes"
                             src="images/tls-config-config-exs.png"
                             style="height: auto; width: 100%"/>
                        <aside class="notes">
                            <p>
                                We need to disable the default HTTP Strict Transport Security because it doesn't work
                                with HTTPS ports other than 443 that are different than the HTTP port.
                            </p>
                            <p>
                                The https setting needs to know where to find the private key and certificate for the
                                server.  Using the OTP app setting allows the paths to be relative.
                            </p>
                            <p>
                                The host in the url setting needs to match the Common Name used in the respective
                                mix environments, so I just use Mix.env in the host name itself.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-configuration-dev">
                        <h1>TLS <code>dev</code> Configuration</h1>
                        <img alt="config/dev.exs TLS changes"
                             src="images/tls-config-dev-exs.png"
                             style="height: auto; width: 100%"/>
                        <aside class="notes">
                            <p>
                                For the redirect from HTTP to HTTPS to work, the force_ssl setting needs to know the
                                HTTPS port, which means that setting is repeated here and for the https port setting
                                itself, so I use variables to show the calculation based on the standard ports
                                of 80 for http and 443 for https and the standard http port of 4000 for phoenix,
                                which means a https port of 4363 to maintain the gap between 80 and 443.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-configuration-prod">
                        <h1>TLS <code>prod</code> Configuration</h1>
                        <img alt="config/prod.exs TLS changes"
                             src="images/tls-config-prod-exs.png"
                             style="height: auto; width: 100%"/>
                        <aside class="notes">
                            <p>
                                Prod follows the same pattern as dev, but without the need for the gap calculation since
                                prod uses the standard ports for http and https.
                            </p>
                        </aside>
                    </section>
                    <section id="tls-configuration-test">
                        <h1>TLS <code>test</code> Configuration</h1>
                        <img alt="config/test.exs TLS changes"
                             src="images/tls-config-test-exs.png"
                             style="height: auto; width: 100%"/>
                        <aside class="notes">
                            Test follows the same pattern as dev.
                        </aside>
                    </section>
                    <section id="tls-testing">
                        <h1>Testing TLS connection</h1>
                        <ol>
                            <li>
                                <figure>
                                    <figcaption>
                                        Start Phoenix: <pre><code>mix phoenix.server</code></pre>
                                    </figcaption>
                                    <img alt="mix phoenix.server print cowboy URL"
                                         src="images/cowboy-urls.png"
                                         style="height: auto; width: 100%"/>
                                </figure>
                            </li>
                            <li>Open HTTP URL printed by Cowboy</li>
                            <li>Verify redirected to HTTPS URL printed by Cowboy</li>
                            <li>
                                <figure>
                                    <figcaption>Verify connection is private</figcaption>
                                    <img alt="Padlock is green and connection is private"
                                         src="images/private-connection.png"
                                         style="height: auto; width: 100%">
                                </figure>
                            </li>
                        </ol>
                        <aside class="notes">
                            <p>
                                With the certificate authority trusted and phoenix server over TLS we have the green
                                padlock and because we used to high bit count, there are no warnings from chrome that
                                the certificate is weak.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="authentication">
                        <h1>Authentication</h1>
                        <ul>
                            <li>
                                <a href="#/authentication-providers">Providers</a>
                            </li>
                            <li>
                                <a href="#/authentication-generate-user-model">
                                    <code>User</code> model
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-user-migration">User Migration</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-schema">User Schema</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-changeset">User Changeset</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-password-hashing">User password hashing</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-registration-routes">User Registration Routers</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-registration-controller">User Registration Controller</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-registration-controller-new">
                                    User Registration Controller <code>new</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-user-view">User View</a>
                            </li>
                            <li>
                                <a href="#/authentication-user-new-template">
                                    User <code>new</code> Template
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-user-registration-controller-create">
                                    User Registration Controller <code>create</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-page-routes">Page Routes</a>
                            </li>
                            <li>
                                <a href="#/authentication-page-controller-authentication">
                                    Page Controller Authentication
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-authenticate-plug">Authenticate Plug</a>
                            </li>
                            <li>
                                <a href="#/authentication-session-routes">Session Routes</a>
                            </li>
                            <li>
                                <a href="#/authentication-session-controller">Session Controller</a>
                            </li>
                            <li>
                                <a href="#/authentication-session-controller-new">
                                    Session Controller <code>new</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-session-view">Session View</a>
                            </li>
                            <li>
                                <a href="#/authentication-session-new-template">
                                    Session <code>new</code> Template
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-session-controller-create">
                                    Session Controller <code>create</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/authentication-session-status">Session Status</a>
                            </li>
                            <li>
                                <a href="#/authentication-session-controller-delete">
                                    Session Controller <code>delete</code>
                                </a>
                            </li>
                        </ul>
                    </section>
                    <section id="authentication-providers">
                        <h1>Authentication Providers</h1>
                        <h2>Don't store passwords if you don't have</h2>
                        <ul>
                            <li>
                                Allow uses to login with OAuth:
                                <ul>
                                    <li>
                                        <a href="https://developers.facebook.com/docs/facebook-login/login-flow-for-web/v2.4">Facebook</a>
                                    </li>
                                    <li>
                                        <a href="https://developer.github.com/guides/basics-of-authentication/">Github</a>
                                    </li>
                                    <li>
                                        <a href="https://developers.google.com/identity/sign-in/web/sign-in">Google</a>
                                    </li>
                                    <li>
                                        <a href="https://dev.twitter.com/web/sign-in">Twitter</a>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                Allow uses to login with SAML:
                                <ul>
                                    <li>
                                        <a href="http://developer.okta.com/docs/guides/saml_guidance.html">Okta</a>
                                    </li>
                                </ul>
                            </li>
                            <li>Store their password</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                If you are making an application on the internet, please consider NOT having your users
                                create a new account and password for your site.  Then you site just becomes another
                                site that can have a password breach.
                            </p>
                            <p>
                                Instead, let password security be someone else's problem: use OAuth to allow sign-in
                                from social networks or use SAML with Okta and allow users to login with their private
                                company ActiveDirectory credentials.
                            </p>
                            <p>
                                If none of these options work for you or you want a fallback in case your users don't
                                have accounts at the other providers, then you can implement passwords in your
                                application.
                            </p>
                            <p>
                                This code for this section is based on Michael Eatherly's
                                "Phoenix app with authentication" from May 11th 2015.  It has been updated for changes
                                in newer versions of Phoenix and some stylistic changes.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-generate-user-model">
                        <h1><code>User</code> model</h1>
                        <table>
                            <caption>
                                <pre><code>mix phoenix.gen.model User users name password_hash</code></pre>
                            </caption>
                            <thead>
                            <tr>
                                <th>Argument</th>
                                <th>Description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <code>User</code>
                                </td>
                                <td>
                                    Module name
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>users</code>
                                </td>
                                <td>
                                    Table name
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <code>name</code>
                                </td>
                                <td>Column name</td>
                            </tr>
                            <tr>
                                <td>
                                    <code>password_hash</code>
                                </td>
                                <td>Column name</td>
                            </tr>
                            </tbody>
                        </table>
                        <img src="images/gen-user-model.png"
                             style="height: auto; width: 100%"/>
                        <aside class="notes">
                            <p>Phoenix has generators for creating models.</p>
                        </aside>
                    </section>
                    <section id="authentication-user-migration">
                        <h1>User Migration</h1>
                        <pre><code class="elixir">
defmodule RoutingSecurelyWithPhoenixFramework.Repo.Migrations.CreateUser do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :name, :string, null: false
      add :password_hash, :string, null: false

      timestamps
    end

    create unique_index(:users, [:name])
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                We create a bare minimum user with a unique name and hashed-password.
                            </p>
                            <p>
                                Note that I called the field password_hash because it's a hashed password it's not
                                encrypted.  A lot of example code confuses encrypted passwords, which can be unencrypted
                                and recovered with hashed passwords, which can't be recovered.  Hash is one-way.
                                Hash password are only cracked by finding the input string that happens to make the
                                same hash as the hash on file.
                            </p>
                            <p>
                                If you ever have to choice between encrypting or hashing passwords, choose hashing
                                passwords and just have users reset their passwords instead of having unencryptable
                                passwords that you can send back to the user when their forget their password.
                            </p>
                            <p>
                                If you can unencrypt a password that means that can attacker that gets access to
                                your unencryption key can also read all your users' passwords.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-schema">
                        <h1>User Schema</h1>
                        <pre><code class="elixir" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.User do
  use RoutingSecurelyWithPhoenixFramework.Web, :model

  schema "users" do
    field :name, :string
    field :password, :string, virtual: true
    field :password_confirmation, :string, virtual: true
    field :password_hash, :string

    timestamps
  end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                <code>schema</code> is a macro for Ecto models that define the type of each field in the
                                Ecto model.
                            </p>
                            <p>
                                The fields aren't automatically inferred from the database because (1) Elixir in general
                                believes in more explicitness and (2) an Ecto model is more separate from the database:
                                it allows for form-only <code>virtual</code> fields, such as <code>password</code> and
                                <code>password_confirmation</code> as seen here.
                            </p>
                            <p>
                                In theory, you can have two Ecto models that point to the same database table and only
                                they can have different real and virtual fields exposed from the database columns.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-changeset">
                        <h1>User Changeset</h1>
                        <pre><code class="elixir stretch">
  @minimum_password_length 16
  @optional_fields ~w()
  @required_fields ~w(name password password_confirmation)

  @doc """
  Creates a changeset based on the `model` and `params`.

  If no params are provided, an invalid changeset is returned
  with no validation performed.
  """
  def changeset(model, params \\ :empty) do
    model
    |> cast(params, @required_fields, @optional_fields)
    |> validate_length(:password, min: @minimum_password_length)
    |> validate_length(:password_confirmation, min: @minimum_password_length)
    |> validate_confirmation(:password)
    |> unique_constraint(:name)
  end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Ecto separates the model, which is a simple Struct from data about whether the params
                                the user passed are valid and what changes need to be persisted to the database in
                                an Ecto dot Changeset (<code>Ecto.Changeset</code>).
                            </p>
                            <p>
                                <code>cast</code> does 3 things: (1) it errors out if a required field is missing in
                                <code>params</code>; (2) it only allows required and optional fields to be copied into
                                the changeset; (3) it converts the allowed params to the type given in the schema.
                            </p>
                            <p>
                                Validations are applied to the changeset and errors are recorded in the returned
                                changeset, so they are just functions, not a DSL.
                            </p>
                            <p>
                                Instead of validating for uniqueness with a SELECT in the database,
                                <code>unique_constraint</code> annotates the changeset, so if there is unique index
                                error from the database, it is transformed back to a validation error.  This is more
                                efficient than validating the uniqueness with SELECT when the call happens because it
                                eliminates a trip to the database and isn't prone to the race conditions of the SELECT
                                either.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-password-hashing">
                        <h1>User password hashing</h1>
                        <pre><code class="elixir stretch">
  @doc """
  Generates a password for the user changeset and stores it to the changeset as encrypted_password.
  """
  def generate_password(changeset) do
    put_change(changeset, :password_hash, Comeonin.Bcrypt.hashpwsalt(changeset.params["password"]))
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                As a general rule one should never write their own encryption, so I'm taking that advise
                                and using the <code>comeonin</code> package to use Bcrypt, which is a known hashing
                                algorithm, to salt each password and hash it for me.
                            </p>
                            <p>
                                Salting adds a randomly generate string to the user's password before hashing, which
                                does 2 things: (1) if two users have the same password, it's stops them from having the
                                same password hash and (2) it makes the passwords harder to crack in bulk because an
                                attacker needs to start over for each salt.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-registration-routes">
                        <h1>User Registration Routes</h1>
                        <pre><code class="elixir" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.Router do
  use RoutingSecurelyWithPhoenixFramework.Web, :router

  scope "/", RoutingSecurelyWithPhoenixFramework do
    pipe_through :browser # Use the default browser stack

    get "/registration", RegistrationController, :new
    post "/registration", RegistrationController, :create
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                For this presentation, we'll limit the user controller to just registering new users,
                                so it'll be the <code>RegistrationController</code> and only have routes for getting
                                the new user form and submitted the form to create the user.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-registration-controller">
                        <h1>User Registration Controller</h1>
                        <pre><code class="elixir" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.RegistrationController do
  use RoutingSecurelyWithPhoenixFramework.Web, :controller

  alias RoutingSecurelyWithPhoenixFramework.User

  plug :scrub_params, "user" when action in [:create]
                        </code></pre>
                        <aside class="notes">
                            <p>
                                We'll use the
                                <a href="http://hexdocs.pm/phoenix/Phoenix.Controller.html#scrub_params/2">scrub_params plug</a>
                                to convert empty strings to nils recursively in the user param.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-registration-controller-new">
                        <h1>User Registration Controller <code>new</code></h1>
                        <pre><code class="elixir stretch" data-trim>
  def new(conn, _params) do
    changeset = User.changeset(%User{})
    render conn, changeset: changeset
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                The <code>new</code> action just renders a changeset for the form.  A changeset is used
                                instead of a <code>User</code> Struct because changesets can hold things like validation
                                errors and previous input, so this way an empty new form and a new from from a failed
                                create can use the same form.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-view">
                        <h1>User View</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.RegistrationView do
  use RoutingSecurelyWithPhoenixFramework.Web, :view
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Using Web view is all that's required for <code>RegistrationView</code> because we're
                                following the standard naming convention for templates.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-new-template">
                        <h1>User <code>new</code> Template</h1>
                        <pre><code class="stretch" data-trim>
&lt;h3&gt;Registration&lt;/h3&gt;
&lt;%= form_for @changeset, registration_path(@conn, :create), fn f -&gt; %&gt;
&lt;%= if f.errors != [] do %&gt;
&lt;div class="alert alert-danger"&gt;
    &lt;p&gt;Oops, something went wrong! Please check the errors below:&lt;/p&gt;
    &lt;ul&gt;
        &lt;%= for {attr, message} &lt;- f.errors do %&gt;
        &lt;li&gt;&lt;%= humanize(attr) %&gt; &lt;%= message %&gt;&lt;/li&gt;
        &lt;% end %&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;% end %&gt;

&lt;div class="form-group"&gt;
    &lt;label&gt;Name&lt;/label&gt;
    &lt;%= text_input f, :name, class: "form-control" %&gt;
&lt;/div&gt;

&lt;div class="form-group"&gt;
    &lt;label&gt;Password&lt;/label&gt;
    &lt;%= password_input f, :password, class: "form-control" %&gt;
&lt;/div&gt;

&lt;div class="form-group"&gt;
    &lt;label&gt;Password Confirmation&lt;/label&gt;
    &lt;%= password_input f, :password_confirmation, class: "form-control" %&gt;
&lt;/div&gt;

&lt;div class="form-group"&gt;
    &lt;%= submit "Register", class: "btn btn-primary" %&gt;
    &lt;%= link("Login", to: session_path(@conn, :new), class: "btn btn-success pull-right") %&gt;
&lt;/div&gt;
&lt;% end %&gt;
                        </code></pre>
                        <aside class="notes">
                            <p>
                                We use the <code>form_for</code> function with the passed in <code>changeset</code>.
                                Passed in variables are called assigns and accessible using the <code>@</code> macro.
                                They are not the same as module attributes, but can be though of as similar because
                                they should be treated as constant for the template.
                            </p>
                            <p>
                                Pay special attention that the percent equals form of the E-E-X tags MUST be used for
                                anything that outputs HTML code.  This includes non-obvious macros like <code>if</code>
                                and <code>for</code>.
                            </p>
                            <p>
                                All the CSS class come from bootstrap, which Phoenix uses by default.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-user-registration-controller-create">
                        <h1>User Registration Controller <code>create</code></h1>
                        <pre><code class="elixir stretch" data-trim>
  def create(conn, %{"user" => user_params}) do
    changeset = User.changeset(%User{}, user_params)

    if changeset.valid? do
      case changeset |> User.generate_password |> Repo.insert do
        {:ok, user} ->
          conn
          |> put_flash(:info, "Successfully registered and logged in")
          |> put_session(:current_user_id, user_id)
          |> redirect(to: page_path(conn, :index))
        {:error, changeset} ->
          render conn, "new.html", changeset: changeset
      end
    else
      render conn, "new.html", changeset: changeset
    end
  end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                When the new form is submitted it goes to the <code>create</code> action in the
                                <code>RegistrationController</code>
                            </p>
                            <p>
                                If the changeset is valid, because the name is present and the password and
                                password_confirmation match and are long enough, then use them to generate the
                                password_hash and insert the user into the repo.
                            </p>
                            <p>
                                But, the insert can fail if the unique constraint is violated, so we check for errors
                                from the insert in the <code>case</code> macro.
                            </p>
                            <p>
                                If there's a validation or a constraint error, then we render the new form with
                                the errors.
                            </p>
                            <p>
                                The current user ID is stored in the session instead of the current user, so that
                                a stale user format can't be retrieved from the session.  It also keeps the session
                                cookie size down since it's only storing an integer instead of a Struct.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-page-routes">
                        <h1>Page Routes</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.Router do
  scope "/", RoutingSecurelyWithPhoenixFramework do
    get "/pages", PageController, :index
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Once logged in, we need a landing page, so we move the <code>PageController</code> route
                                from slash (<code>/</code>) to slash pages (<code>/pages</code>).
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-page-controller-authentication">
                        <h1>Page Controller Authentication</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.PageController do
  plug RoutingSecurelyWithPhoenixFramework.Plug.Authenticate
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                We only want logged in users to see the pages, so we'll use a plug to check that users
                                are authenticated.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-authenticate-plug">
                        <h1>Authenticate Plug</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.Plug.Authenticate do
  import RoutingSecurelyWithPhoenixFramework.Router.Helpers

  alias RoutingSecurelyWithPhoenixFramework.Repo
  alias RoutingSecurelyWithPhoenixFramework.User

  def init(opts) do
    opts
  end

  def call(conn, _opts) do
    assign_current_user(conn)
  end

  defp assign_current_user(conn = %Plug.Conn{}) do
    assign_current_user(conn, Plug.Conn.get_session(conn, :current_user_id))
  end
  defp assign_current_user(conn, id) when is_integer(id) do
    assign_current_user(conn, Repo.get(User, id))
  end
  defp assign_current_user(conn, user = %User{}) do
    Plug.Conn.assign(conn, :current_user, user)
  end
  defp assign_current_user(conn, _), do: redirect_to_sign_in(conn)

  defp redirect_to_sign_in(conn) do
    conn
    |> Phoenix.Controller.put_flash(
         :error,
         'You need to be signed in to view this page'
       )
    |> Phoenix.Controller.redirect(to: session_path(conn, :new))
    |> Plug.Conn.halt
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Plugs can either be functions or Modules.  Modules have the benefit of allowing options to
                                be passed to the plug macro call.  Here we're not using the <code>opts</code>, so they just
                                pass through unused in <code>init/2</code> to maintain the signature and are prefixed with
                                underscore (<code>_opts</code>) to let the compiler know we expect to not use the variable
                                in <code>call</code>.
                            </p>
                            <p>
                                The bulk of the plug is the assign current user function, where is clause does a single
                                transformation convert a connection to a user id to a user  The final clause handles
                                both if the current user id is <code>nil</code> or if the user is <code>nil</code>.
                            </p>
                            <p>
                                The Plug dot conn dot halt (<code>Plug.Conn.halt</code>) is important as it stops the
                                pipeline of plugs, including the action from running.  Without it, you'll get a
                                a plug dot conn dot already sent error (<code>Plug.Conn.AlreadySentError</code>).  Being
                                able to mark a conn as halted is what elevates plug pipelines above the level of pipe
                                arrow (<code>|></code>) pipelines in standard Elixir: you can stop a pipeline when there
                                is an error and not have to do <code>:ok</code> and <code>:error</code> cases for every
                                later function in the pipeline.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-routes">
                        <h1>Session Routes</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.Router do
  scope "/", RoutingSecurelyWithPhoenixFramework do
    get "/", SessionController, :new
    post "/login", SessionController, :create
    get "/logout", SessionController, :delete
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Registering uses are automatically signed in, but users need a way to login when returning to
                                the site (and logout on demand).
                            </p>
                            <p>
                                There is no unprotected pages besides registration, so slash (<code>/</code>) will now log
                                to the login page.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-controller">
                        <h1>Session Controller</h1>
                          <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.SessionController do
  use RoutingSecurelyWithPhoenixFramework.Web, :controller

  alias RoutingSecurelyWithPhoenixFramework.User

  plug :scrub_params, "user" when action in [:create]
                          </code></pre>
                        <aside class="notes">
                            <p>
                                Like <code>RegistrationController</code>, we're using <code>scrub_params</code> to convert
                                empty strings to <code>nil</code> for <code>create</code>.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-controller-new">
                        <h1>Session Controller <code>new</code></h1>
                        <pre><code class="elixir stretch" data-trim>
  def new(conn, _params) do
    render conn, changeset: User.changeset(%User{})
  end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                The <code>new</code> code uses changeset just like the registration controller's
                                <code>new</code> to allow for form errors.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-view">
                        <h1>Session View</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.SessionView do
  use RoutingSecurelyWithPhoenixFramework.Web, :view
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                Once again, we're using HTML, so the <code>SessionView</code> is just boiler plate.
                            </p>
                            <p>
                                I swear having a separate view and template is useful, but it's mostly used for JSON
                                views in my experience.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-new-template">
                        <h1>Session <code>new</code> Template</h1>
                        <pre><code class="stretch" data-trim>
&lt;h3&gt;Login&lt;/h3&gt;
&lt;%= form_for @changeset, session_path(@conn, :create), fn f -&gt; %&gt;
&lt;%= if f.errors != [] do %&gt;
&lt;div class="alert alert-danger"&gt;
    &lt;p&gt;Oops, something went wrong! Please check the errors below:&lt;/p&gt;
    &lt;ul&gt;
        &lt;%= for {attr, message} &lt;- f.errors do %&gt;
        &lt;li&gt;&lt;%= humanize(attr) %&gt; &lt;%= message %&gt;&lt;/li&gt;
        &lt;% end %&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;% end %&gt;

&lt;div class="form-group"&gt;
    &lt;label&gt;Name&lt;/label&gt;
    &lt;%= text_input f, :name, class: "form-control" %&gt;
&lt;/div&gt;

&lt;div class="form-group"&gt;
    &lt;label&gt;Password&lt;/label&gt;
    &lt;%= password_input f, :password, class: "form-control" %&gt;
&lt;/div&gt;

&lt;div class="form-group"&gt;
    &lt;%= submit "Login", class: "btn btn-primary" %&gt;
    &lt;%= link("Sign Up", to: registration_path(@conn, :new), class: "btn btn-success pull-right") %&gt;
&lt;/div&gt;
&lt;% end %&gt;                            
                        </code></pre>
                        <aside class="notes">
                            <p>
                                It's pretty much the same form as for registration, just without the password
                                confirmation.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-controller-create">
                        <h1>Session Controller <code>create</code></h1>
                        <pre><code class="elixir stretch" data-trim>
  def create(conn, %{"user" => user_params}) do
    if is_nil(user_params["name"]) do
      nil
    else
      Repo.get_by(User, name: user_params["name"])
    end
    |> sign_in(user_params["password"], conn)
  end
  # Private Functions

  @sign_in_error "Name or password are incorrect."

  defp sign_in(user, _password, conn) when is_nil(user) do
    conn
    |> put_flash(:error, @sign_in_error)
    |> render "new.html", changeset: User.changeset(%User{})
  end

  defp sign_in(user, password, conn) when is_map(user) do
    if Comeonin.Bcrypt.checkpw(password, user.password_hash) do
      conn
      |> put_session(:current_user_id, user.id)
      |> put_flash(:info, "You are now signed in.")
      |> redirect(to: page_path(conn, :index))
    else
      conn
      |> put_flash(:error, @sign_in_error)
      |> render "new.html", changeset: User.changeset(%User{})
    end
  end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                When the <code>new</code> form is submitted, <code>create</code> will attempt to login
                                the user.
                            </p>
                            <p>
                                <code>create</code> only looks up the user if the name is set, saving a trip to the
                                database.
                            </p>
                            <p>
                                The retrieved user or nil is then passed to <code>sign_in</code>, which uses a guard
                                to show an error when the user is nil, which handles both the user name being nil and
                                the user not being found in the database.
                            </p>
                            <p>
                                If the user is found in the database, when come on in's bcrypt support is used to
                                check the password against the stored password hash. If the password is correct, then
                                the users is signed in and redirected to the landing page.
                            </p>
                            <p>
                                If the password is incorrect, an error is shown by redirecting to the new form.
                            </p>
                            <p>
                                Take note of the sign in error module attribute (<code>@sign_in_error</code>).  I make
                                sure to use same error whether the name and/or password is incorrect.  I don't want
                                to disclose if the name is correct, but the password is wrong as that allows for user
                                enumeration, which can help with other attacks.
                            </p>
                            <p>
                                However, for this specific application, because there is open registration, users can
                                be enumerated by trying names and seeing if they are already taken.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-status">
                        <h1>Session Status</h1>
                        <pre><code class="stretch" data-trim>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;body&gt;
    &lt;nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt;
      &lt;div class="container"&gt;
       &lt;div id="navbar" class="navbar-collapse collapse"&gt;
          &lt;div class="navbar-form navbar-right"&gt;
          &lt;%= case @conn.assigns[:current_user] do %&gt;
          &lt;%    nil -&gt; %&gt;
            &lt;%= link "Login", class: "btn btn-success", role: "button", to: session_path(@conn, :new) %&gt;
          &lt;%    current_user -&gt; %&gt;
            &lt;span class="label label-info"&gt;
              &lt;%= current_user.name %&gt;
            &lt;/span&gt;
            &lt;%= link "Logout", class: "btn btn-danger", role: "button", to: session_path(@conn, :delete) %&gt;
          &lt;% end %&gt;
          &lt;/div&gt;
        &lt;/div&gt;&lt;!--/.navbar-collapse --&gt;
      &lt;/div&gt;
    &lt;/nav&gt;
  &lt;/body&gt;
&lt;/html&gt;
                        </code></pre>
                        <aside class="notes">
                            <p>
                                The current user will only be assigned if the user is logged in, so
                                we use access look-up on at conn dor assigns (<code>@conn.assigns</code>) instead of
                                using at current underscore user (<code>@current_user</code>).  If the current
                                user assign is <code>nil</code>, then show a login button, otherwise show the user
                                their name and a logout button.
                            </p>
                        </aside>
                    </section>
                    <section id="authentication-session-controller-delete">
                        <h1>Session Controller <code>delete</code></h1>
                        <pre><code class="elixir stretch" data-trim>
def delete(conn, _) do
  delete_session(conn, :current_user_id)
  |> put_flash(:info, "You have been logged out")
  |> redirect(to: session_path(conn, :new))
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                If the user clicks the logout button, we delete the session and redirect back to login
                                since all pages are protected.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="#csrf">
                        <h1>CSRF</h1>
                        <ul>
                            <li>
                                <a href="#/csrf-definition">Overview</a>
                            </li>
                            <li>
                                <a href="#/csrf-false-protections">False CSRF Protections</a>
                            </li>
                            <li>
                                <a href="#/csrf-protections">CSRF Protections</a>
                            </li>
                            <li>
                                <a href="#/csrf-token-in-forms">CSRF Token in Forms</a>
                            </li>
                            <li>
                                <a href="#/csrf-verificaiton">CSRF Token Verification</a>
                            </li>
                            <li>
                                <a href=#/csrf-same-origin-policy>Same Origin Policy</a>
                            </li>
                        </ul>
                    </section>
                    <section id="csrf-overview">
                        <h1>CSRF</h1>
                        <h2>Cross-Site Request Forgery</h2>
                        <ol>
                            <li>User is logged into goodsite.com</li>
                            <li>User visits badsite.com</li>
                            <li>badsite.com contains a link to goodsite.com/widgets/sell</li>
                            <li>User's browser fetches link to goodsite.com using cookie from goodsite.com</li>
                            <li>badsite.com has just sold in User's account on goodsite.com to attacker</li>
                        </ol>
                        <aside class="notes">
                            <p>
                                C-S-R-F stands for cross-site request forgery.  It happens when one site is able to
                                force a user to execute actions on another site because browsers automatically send
                                cookies to the respective sites.
                            </p>
                        </aside>
                    </section>
                    <section id="csrf-false-protections">
                        <h1>False CSRF Protections</h1>
                        <ul>
                            <li>Secret Cookie</li>
                            <li>Not accepting <code>GET</code> requests</li>
                            <li>Multi-Step Transactions</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Having a secret cookie doesn't matter because all cookies are sent to the site that
                                created them.
                            </p>
                            <p>
                                Only allowing <code>DELETE</code>, <code>PATCH</code>, <code>POST</code>, and
                                <code>PUT</code> requests and not <code>GET</code> requests would prevent links
                                triggering CSRF, but a malicious site can easily construct <code>POST</code> requests
                                using hidden form fields or javascript.
                            </p>
                            <p>
                                Having a complex set of steps to complete a transaction, such may pages and forms to
                                fill to do a bank transfer doesn't protect if the attacker and figure out the
                                correct sequence of requests to fake those steps.
                            </p>
                            <p>
                                Rewriting URLs would involve putting the user's session ID in the URL, which means that
                                anything that saves the URL, such as the history, then has the user's session ID in it,
                                which can be recovered by an attacker.
                            </p>
                        </aside>
                    </section>
                    <section id="csrf-protections">
                        <h1>CSRF Protections</h1>
                        <ul>
                            <li><code>GET</code> requests MUST NOT change state</li>
                            <li>No XSS vulnerabilities</li>
                            <li>Double submit cookie in requests that change state</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                It is your responsibility as a developer to not have <code>GET</code> requests change
                                state.  In addition to malicious attackers, spiders for most search engine will follow
                                <code>GET</code> links, but not other requests, so if you have a <code>GET</code>
                                link that changes state, then a search engine spider can blinding start altering
                                your application state.
                            </p>
                            <p>
                                Right now, the application isn't vulnerable to cross-site scripting (XSS) because no
                                input from one user is viewable by another user, but we'll cover X-S-S protections
                                when we get to the chat.
                            </p>
                            <p>
                                Using a unique token for each form is the current standard for protecting forms in
                                web frameworks including DJango, Ruby on Rails, and Phoenix.
                            </p>
                        </aside>
                    </section>
                    <section id="csrf-token-in-forms">
                        <h1>CSRF Token in Forms</h1>
                        <pre><code data-trim>
&lt;h3&gt;Registration&lt;/h3&gt;
&lt;%= form_for @changeset, registration_path(@conn, :create), fn f -&gt; %&gt;                            
                        </code></pre>
                        <pre><code data-trim>
&lt;form accept-charset="UTF-8" action="/registration" method="post"&gt;
    &lt;input name="_csrf_token" type="hidden" value="e3JoLCxfDyBXFHYaNVgjOwEeQx4uNgAA000tv4wt1p1bv4wOMVtHiQ=="&gt;
                        </code></pre>
                        <aside class="notes">
                            <p>
                                We've actually already enabled CSRF protection in our forms by using the
                                <code>form_for</code> function, which adds a hidden input for underscore C-S-R-F
                                underscore token (<code>_csrf_token</code>)
                            </p>
                        </aside>
                    </section>
                    <section i="csrf-verification">
                        <h1>CSRF Token Verification</h1>
                        <h2><code>_csrf_token</code> (param) == <code>_csrf_token</code> (session)</h2>
                        <aside class="notes">
                            <p>
                                The CSRF token is verified by comparing the token submitted in the request with the
                                token storied in the session.
                            </p>
                            <p>
                                The CSRF token in the session can be trusted even when stored in a cookie (as is the
                                default) because the cookie is signed and encrypted so that the user cannot tamper
                                with it.
                            </p>
                            <p>
                                Each GET request for a form included a new CSRF token and modifies the session cookie
                                so it has that same CSRF token in it.  The reason an attacker cannot read the
                                the form to recover the CSRF token a resubmit with the updated cookie due to the same
                                origin policy.
                            </p>
                        </aside>
                    </section>
                    <section id="csrf-same-origin-policy">
                        <h1>Same Origin Policy</h1>
                        <h2><a href="https://tools.ietf.org/html/rfc6454#section-4">RFC 6454</a></h2>
                        <ul>
                            <li>Protocol</li>
                            <li>Host</li>
                            <li>Port</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Web browsers ensure that requests from one page to another are only allowed if the
                                protocol, host, and port match.
                            </p>
                            <p>
                                This prevents resources from the http version of a site accessing the secure https
                                version of a site; google.com accessing your bank's site; and two internal apps
                                running on different ports on your companies intranet from accessing each other.
                            </p>
                            <p>
                                Without same origin, CSRF couldn't be prevented with storing the token in both
                                a resource the form and the cookie because the attacker could read the form, fill it
                                in (with the hidden CSRF token) and the browser would send along the cookies on the
                                attacker's behalf.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="channels">
                        <h1>Channels</h1>
                        <ul>
                            <li>
                                <a href="#/channel-overview">Overview</a>
                            </li>
                            <li>
                                <a href="#/channels-template-pages">Pages Template</a>
                            </li>
                            <li>
                                <a href="#/channels-jquery">jQuery</a>
                            </li>
                            <li>
                                <a href="#/channels-socket-js">
                                    <code>socket.js</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-socket-token-meta-tag">
                                    <code>socket_token</code> <code>meta</code> tag
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-adding-socket-token-to-users">
                                   Adding <code>socket_token</code> to <code>users</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-adding-socket-token-to-user-schema">
                                   Adding <code>socket_token</code> to <code>User</code> schema
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-generating-secrets-on-registration">
                                    Generating secrets on registration
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-user-full-changeset">
                                    <code>User.full_changeset/1</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-user-socket-connect">
                                    <code>UserSocket.connect/2</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-user-socket-id">
                                    <code>UserSocket.id/1</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-room-channel">
                                    <code>RoomChannel</code>
                                </a>
                            </li>
                            <li>
                                <a href="#/channels-demo">
                                    Demo
                                </a>
                            </li>
                        </ul>
                    </section>
                    <section id="channel-overview">
                        <h1>Overview</h1>
                        <ul>
                            <li>Bidirectional communications from clients</li>
                            <li>Transported over Websockets or Long Polling</li>
                            <li>Browser, Android, and iOS clients</li>
                            <li>Distributed over PubSub layer between Phoenix nodes</li>
                        </ul>
                        <aside class="notes">
                            <p>
                                Channels are one of the cooler features of Phoenix where the concurrency support of
                                the BEAM really signs.  Instead of a standard request response cycle, channels allow
                                bidirectional communication over websockets that remain open.  Allowing messages to be
                                pushed from the server to the client and between clients through the server.
                            </p>
                            <p>
                                An obvious use for this is soft-realtime chat between users.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-template-pages">
                        <h1>Pages Template</h1>
                        <pre><code data-trim>
&lt;div id="messages" class="container"&gt;&lt;/div&gt;
&lt;div id="footer"&gt;
  &lt;div class="container"&gt;
    &lt;div class="row"&gt;
      &lt;div class="col-sm-12"&gt;
        &lt;label for="message-input"&gt;Your Message:&lt;/label&gt;
        &lt;textarea id="message-input" class="form-control"&gt;
        &lt;/textarea&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
                        </code></pre>
                        <aside class="notes">
                            <p>
                                To the bottom of web slash templates slash page slash index dot html dot E-E-X
                                (<code>web/templates/page/index.html</code>) we'll add a div for the chat messages
                                and an input box where the user can type messages.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-jquery">
                        <h1>jQuery</h1>
                        <figure>
                            <figcaption>
                                <code>package.json</code>
                            </figcaption>
                            <pre><code class="javascript" data-trim style="width: 100%">
{
  "dependencies": {
    "jquery": "~2.1"
  }
}

                            </code></pre>
                        </figure>
                        <figure>
                            <figcaption>
                                <code>brunch-config.js</code>
                                <pre><code class="javascript" data-trim style="width: 100%">
exports.config = {
  plugins: {
    babel: {
      // Do not use ES6 compiler in vendor code
      ignore: [/web\/static\/vendor/, /node_modules\/jquery/]
    }
  },
};
                                </code></pre>
                            </figcaption>
                        </figure>
                        <aside class="notes">
                            <p>
                                To make registering for events and updating the dom, I'm going to use jQuery.
                            </p>
                            <p>
                                I need to jQuery to my package.json for node to install it and I need to tell, Babel,
                                the ES6 to ES5 transpiler to ignore jQuery since jQuery is already ES5.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-socket-js">
                        <h1><code>socket.js</code></h1>
                        <pre><code class="javascript stretch" data-trim>
import {Socket} from "deps/phoenix/web/static/js/phoenix"
import $ from "jquery"

let socket = new Socket("/socket")
let socketToken = $("meta[name='socket_token']").attr("content")

if (socketToken !== undefined) {
  socket.connect({token: socketToken})

  // Now that you are connected, you can join the lobby
  let channel = socket.channel("rooms:lobby", {})

  let messageInput = $("#message-input")

  messageInput.on("keypress", event => {
    if (event.keyCode === 13) {
      channel.push("new_message", {body: messageInput.val()})
      messageInput.val("")
    }
  })

  let messagesContainer = $("#messages")

  channel.on("new_message", payload => {
    messagesContainer.append(
      `<p>
        <span class="date-time">${Date()}</span>
        <span class="user-name">${payload.user.name}</span>
        ${payload.body}
       </p>`
    )
  })

  channel.join()
}

export default socket
                        </code></pre>
                        <aside class="notes">
                            <p>
                                mix phoenix dot new (<code>mix phoenix.new</code>) generates a socket dot J-S
                                (<code>socket.js</code>) that is disabled by default.  We'll not fill it in for our
                                chat.
                            </p>
                            <p>
                                We'll get a socket_token from a meta tag because channels aren't tied to HTTP-based
                                transports, so we can't depend on headers being sent and cookies are headers.
                            </p>
                            <p>
                                rooms colon lobby (<code>rooms:lobby</code>) is an example channel from mix phoenix
                                dot new (<code>mix phoenix.new</code>).
                            </p>
                            <p>
                                The chat interface waits for the user to press enter, which sends the message to the
                                server.  The server then broadcasts that message to all the users in rooms colon lobby
                                and they add the message to the chat log.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-socket-token-meta-tag">
                        <h1><code>socket_token</code> <code>meta</code> tag</h1>
                        <pre><code data-trim>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
  &lt;%= case @conn.assigns[:current_user] do %&gt;
  &lt;%    nil -&gt; %&gt;
  &lt;%    current_user -&gt; %&gt;
    &lt;%= tag :meta,
            content: Phoenix.Token.sign(@conn, "user", {current_user.id, current_user.socket_token}),
            name: "socket_token" %&gt;
  &lt;% end %&gt;
  &lt;/head&gt;
&lt;/html&gt;
                        </code></pre>
                        <aside class="notes">
                            <p>
                                So, to make socket.js work we need to make socket underscore token available in a
                                metatag, which we do by adding it to the layout.
                            </p>
                            <p>
                                This has to be protected if a user isn't logged in since the layout is used on
                                login and registration pages.
                            </p>
                            <p>
                                To generate the actual token, we use Phoenix dot Token dot sign
                                (<code>Phoenix.Token.sign</code>), passing user (<code>"user"</code>) as the salt,
                                which must be know on the sending and receiving side and both the user ID and the
                                user's socket token, which hasn't been defined yet in the User model.
                            </p>
                            <p>
                                The socket token is used along with the id, so that the socket token can be changed
                                if the user account is compromised and it will invalidate the signed tokens embedded
                                in any open pages.
                            </p>
                            <p>
                                If just the user id is used, then there's no way to invalidate the signed token
                                besides having the token expired as the sign function embeds the signing time, but
                                if you can't easily make the expiration time for one user's token be earlier.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-adding-socket-token-to-users">
                        <h1>Adding <code>socket_token</code> to <code>users</code></h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.Repo.Migrations.AddChannelTokenToUser do
  use Ecto.Migration

  def down do
    alter table(:users) do
      remove :socket_token
    end
  end

  def up do
    alter table(:users) do
      # add socket_token as null because it needs to be populated first
      add :socket_token, :string, null: true
    end

    # populate with secure random value using same algorithm as `mix phoenix.gen.secret`
    execute "CREATE EXTENSION IF NOT EXISTS pgcrypto"
    execute "UPDATE users SET socket_token = encode(gen_random_bytes(64), 'base64') WHERE socket_token IS NULL"

    alter table(:users) do
      modify :socket_token, :string, null: false
    end
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                The migration has to do the dance of making a null column, populating it, then making
                                it not null to handle any pre-existing user accounts.
                            </p>
                            <p>
                                To populate the field, we want strong random bytes, so we'll use the gen_random_bytes
                                function from the P-G crypto (<code>pgcrypto</code>) extension for PostgreSQL.
                            </p>
                            <p>
                                To be able to use <code>CREATE EXTENSION</code>, the database user will need to have
                                superuser permissions.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-adding-socket-token-to-user-schema">
                        <h1>Adding <code>socket_token</code> to <code>User</code> schema</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.User do
  schema "users" do
    field :socket_token, :string
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                To be able to access the field from Ecto, we need to add socket token as a field to the
                                <code>User</code> schema.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-generating-secrets-on-registration">
                        <h1>Generating secrets on registration</h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.RegistrationController do
  def create(conn, %{"user" => user_params}) do
    changeset = User.changeset(%User{}, user_params)

    if changeset.valid? do
      full_changeset = User.full_changeset(changeset)

      case Repo.insert(full_changeset) do
        {:ok, user} ->
          conn
          |> put_flash(:info, "Successfully registered and logged in")
          |> put_session(:current_user_id, user.id)
          |> redirect(to: page_path(conn, :index))
        {:error, changeset} ->
          render conn, "new.html", changeset: changeset
      end
    else
      render conn, "new.html", changeset: changeset
    end
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                We already had to generate the password hash when create users, now we'll also generate
                                the socket token.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-user-full-changeset">
                        <h1><code>User.full_changeset/1</code></h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.User do
  @socket_token_length 64

  @doc """
  Fills `changeset` with generated columns.
  """
  def full_changeset(changeset) do
    changeset
    |> generate_password
    |> generate_socket_token
  end

  @doc """
  Generates a channel token for the user changeset.
  """
  def generate_socket_token(changeset) do
    put_change(changeset, :socket_token, generate_secret(@socket_token_length))
  end

  # Private Functions

  @doc """
  Generates a random secret string of the given `length`
  """
  defp generate_secret(length) do
    :crypto.strong_rand_bytes(length) |> Base.encode64 |> binary_part(0, length)
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                generate secret (<code>generate_secret</code>) is the same code we used in the beginning
                                to generate new secret key bases for configs.  The code is extracted from
                                mix phoenix dot gen dot secret (<code>mix phoenix.gen.secret</code>).
                            </p>
                            <p>
                                We can now send the signed socket token back to the server, but the server needs to
                                verify the token on connect.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-user-socket-connect">
                        <h1><code>UserSocket.connect/2</code></h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.UserSocket do
  @seconds_per_minute 60
  @minutes_per_hour 60
  @hours_per_day 24
  @days_per_week 7
  @token_max_age 2 * @days_per_week * @hours_per_day * @minutes_per_hour *
                 @seconds_per_minute

  def connect(%{"token" => token}, socket) do
    case Phoenix.Token.verify(socket, "user", token, max_age: @token_max_age) do
      {:ok, {id, socket_token}} ->
        connect_user_id_and_socket_token(socket, id, socket_token)
      {:error, reason} ->
        :error
    end
  end

  defp connect_user(socket, user) do
    socket = assign(socket, :user_id, user.id)
    {:ok, socket}
  end

  defp connect_user_id_and_socket_token(socket, id, socket_token) do
    user = Repo.get_by!(User, id: id, socket_token: socket_token)
    connect_user socket, user
  end
end

                        </code></pre>
                        <aside class="notes">
                            <p>
                                I'm having the token expire every 2 just to demonstrate how to do that and because
                                the Phoenix guides use it as an example.
                            </p>
                            <p>
                                Phoenix dot Token dot verify (<code>Phoenix.Token.verify</code>) only verifies the
                                token is signed correctly and not expired, but that's not enough if a user's account
                                has been compromised and needed a credentials recent in the interim since the token
                                was signed.
                            </p>
                            <p>
                                To verify the token represents the user's current credentials, we use Repo dot get by
                                bang (<code>Repo.get_by!</code>), which will raise an exception and kill the socket
                                attempt if the id and socket_token don't BOTH match.  This will exclude deleted
                                users too.
                            </p>
                            <p>
                                We store th user ID instead of the <code>User</code> Struct directly so we don't have to
                                worry about it becoming stale.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-user-socket-id">
                        <h1><code>UserSocket.id/1</code></h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.UserSocket do
  # Disconnecting a compromised user

      iex> RoutingSecurelyWithPhoenixFramework.Endpoint.broadcast("user_sockets:" <> user_id, "disconnect")
  """
  def id(socket) do
    "user_sockets:#{socket.assigns.user_id}"
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                To allow us to kick all sockets from a given users, such as if the user becomes
                                compromised or just needs the banhammer brought down on them, we can assign an id,
                                which functions as a channel that all sockets for a given user belong to.
                            </p>
                        </aside>
                    </section>
                    <section id="channels-room-channel">
                        <h1><code>RoomChannel</code></h1>
                        <pre><code class="elixir stretch" data-trim>
defmodule RoutingSecurelyWithPhoenixFramework.RoomChannel do
  use RoutingSecurelyWithPhoenixFramework.Web, :channel

  def join("rooms:lobby", _payload, socket) do
    {:ok, socket}
  end

  @doc """
  Get user from `socket` before handling event.
  """
  def handle_in(event, params, socket) do
    user = Repo.get! User, socket.assigns.user_id
    handle_in(event, params, user, socket)
  end

  @doc """
  Broadcast a message from one user to all users (including the originating user)
  """
  def handle_in("new_message", %{"body" => body}, user, socket) do
    broadcast! socket,
               "new_message",
               %{
                  body: body,
                  user: %{
                    name: user.name
                  }
               }
    {:noreply, socket}
  end
end
                        </code></pre>
                        <aside class="notes">
                            <p>
                                I let anyone that's got a socket, join the lobby.
                            </p>
                            <p>
                                handle in slash 3 (<code>handle_in/3</code>) looks up the user from the user id and then
                                calls handle in slash 4 (<cdoe>handle_in/4</cdoe>).
                            </p>
                        </aside>
                    </section>
                    <section id="channels-demo">
                        <h1>Demo</h1>
                        <video data-autoplay src="videos/xss-message.m4v"></video>
                        <aside class="notes">
                            <p>
                                I have 2 accounts logged in: Kronic Deth on the left and Chuck on the right.
                            </p>
                            <p>
                                Chuck decides to test the security of the chat by posting a script tag...
                            </p>
                            <p>
                                And Chuck just posted a message using Kronic Deth's token.
                            </p>
                        </aside>
                    </section>
                </section>
                <section>
                    <h1>Sources</h1>
                    <ul>
                        <li>
                            <a href="http://www.phoenixframework.org/docs/installation">Phoenix Framework Installation Guide</a>
                        </li>
                        <li>
                            <code>mix help phoenix.new</code>
                        </li>
                        <li>
                            <a href="http://datacenteroverlords.com/2012/03/01/creating-your-own-ssl-certificate-authority/">Creating your own SSL Certificate Authority</a>
                        </li>
                        <li>
                            <a href="http://web.mit.edu/crypto/openssl.cnf">MIT openssl configuration file</a>
                        </li>
                        <li>
                            <a href="http://rcardon.free.fr/websign/download/api-x509-ext/be/cardon/asn1/x509/extensions/KeyUsage.html">Key Usage docs</a>
                        </li>
                        <li>
                            Metasploit Pro
                        </li>
                        <li>
                            <a href="https://meatherly.github.io/2015/05/11/phoenixauthentication">Phoenix app with authentication</a>
                        </li>
                        <li>
                            <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)">Cros-Site Request Forgery (CSRF)</a>
                        </li>
                        <li>
                            <a href="https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet">CSRF Prevention Cheat Sheet</a>
                        </li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Same-origin_policy">Same-origin policy</a>
                        </li>
                        <li>
                            <a href="https://tools.ietf.org/html/rfc6454#section-4">RFC 6454</a>
                        </li>
                        <li>
                            <a href="http://hexdocs.pm/phoenix/Phoenix.Token.html">
                                <code>Phoenix.Token</code>
                            </a>
                        </li>
                    </ul>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                center: true,
                controls: true,
                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ],
                height: 1280,
                history: true,
                progress: true,
                // Slide number formatting can be configured using these variables:
                //  h: current slide's horizontal index
                //  v: current slide's vertical index
                //  c: current slide index (flattened)
                //  t: total number of slides (flattened)
                slideNumber: 'c / t',
                transition: 'slide', // none/fade/slide/convex/concave/zoom
                width: 2048
            });

        </script>

	</body>
</html>
